## Need to construct a Cn then combine it to the following functions.


## Corrected VAR likelihood (frequency domain): f- and q-parametrization (see gibbs_multivariate_util.R)
llike_var_corrected <- function(FZ, ar, f_param_half, sigma, f, excludeBoundary=T) { # exclude lambda_{0,N} for mean-centered TS
  d <- ncol(FZ)
  f_half <- chol_cube(f, excludeBoundary) 
  f_half_inv <- inv_cube(f_half, excludeBoundary)
  CFZ <- get_CFZ(FZ, f_half_inv, f_param_half, excludeBoundary)
  FCFZ <- Re(midft(CFZ))
  ll <- 2*sum(logdet_cube(f_half_inv, excludeBoundary)) + # times 2, because of functional determinant in real-valued formulation
    2*sum(logdet_cube(f_param_half, excludeBoundary)) + # times 2, because of functional determinant in real-valued formulation
    llike_var_partial(FCFZ, ar, sigma=sigma)
  return(ll)
}


## See gibbs_mutivariate_util.cpp
arma::cx_cube chol_cube(ComplexVector f_, bool excludeBoundary) { // ok
  const arma::cx_cube f = cx_cube_from_ComplexVector(f_);
  arma::cx_cube f_half(f.n_rows, f.n_cols, f.n_slices); // Carful: No fill
  if (excludeBoundary) {
    f_half.slice(0) = arma::cx_mat(f.n_rows, f.n_cols, arma::fill::zeros);
    f_half.slice(f.n_slices-1) = arma::cx_mat(f.n_rows, f.n_cols, arma::fill::zeros);
  }
  for (unsigned j=excludeBoundary; j < f.n_slices-excludeBoundary; ++j) {
    f_half.slice(j) = trans(arma::chol(f.slice(j)));
  }
  return f_half;
}



## See gibbs_mutivariate_util.cpp
arma::cx_cube inv_cube(ComplexVector f_, bool excludeBoundary) { // ok
  const arma::cx_cube f = cx_cube_from_ComplexVector(f_);
  arma::cx_cube f_inv(f.n_rows, f.n_cols, f.n_slices); // Carful: No fill
  if (excludeBoundary) {
    f_inv.slice(0) = arma::cx_mat(f.n_rows, f.n_cols, arma::fill::zeros);
    f_inv.slice(f.n_slices-1) = arma::cx_mat(f.n_rows, f.n_cols, arma::fill::zeros);
  }
  for (unsigned j=excludeBoundary; j < f.n_slices-excludeBoundary; ++j) {
    f_inv.slice(j) = arma::inv(f.slice(j));
  }
  return f_inv;
}





## Construct CFZ (see gibbs_mutivariate_util.cpp)
arma::cx_mat get_CFZ(arma::cx_mat FZ, ComplexVector f_half_inv_, 
                     ComplexVector f_param_half_, bool excludeBoundary) {
  const arma::cx_cube f_half_inv = cx_cube_from_ComplexVector(f_half_inv_);
  const arma::cx_cube f_param_half = cx_cube_from_ComplexVector(f_param_half_);
  arma::cx_mat res(FZ.n_rows, FZ.n_cols);
  if (excludeBoundary) {
    res.row(0) = arma::cx_rowvec(FZ.n_cols, arma::fill::zeros);
    res.row(FZ.n_rows-1) = arma::cx_rowvec(FZ.n_cols, arma::fill::zeros);
  }
  for (unsigned j=excludeBoundary; j<FZ.n_rows-excludeBoundary; ++j) {
    res.row(j) = (f_param_half.slice(j) * f_half_inv.slice(j) * FZ.row(j).st()).st();
  }
  return res;
}







## Multivariate inverse discrete (fast) Fourier Transform (see gibbs_multivariate_util.R)
midft <- function(FZ, real=F) {
  Z <- apply(FZ, 2, fast_ift, real=real)
  return(Z)
}



